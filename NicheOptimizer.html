from pathlib import Path
import re, textwrap, json, datetime

# ---------- Build backend app.js ----------
backend = r"""/**
 * STREAMER & NICHE AI HUB - BACKEND (V58 - routes coh√©rentes + stats p√©dagogiques + s√©lection <=100 viewers)
 * ================================================================================================
 * Objectifs:
 * - Garder tes routes existantes + compat avec l'ancien front
 * - Ajouter des routes "random streamer" (global et par jeu) avec cap viewers (0..100 par d√©faut)
 * - Assurer que daily_stats existe (rollup journalier via cron snapshot) pour analytics/alerts
 * - Remplir games/{gameId}/hourly_stats pour l'outil /api/games/hours
 * - Socket.IO stable (websocket only)
 *
 * Env requis:
 * - TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET, TWITCH_REDIRECT_URI
 * - (optionnel) FIREBASE_SERVICE_KEY (json string) ou serviceAccountKey.json
 * - (optionnel) GEMINI_API_KEY
 */

require('dotenv').config();

const express = require('express');
const cors = require('cors');
const fetch = require('node-fetch');
const bodyParser = require('body-parser');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const cookieParser = require('cookie-parser');
const http = require('http');
const { Server } = require('socket.io');

// IA
const { GoogleGenAI } = require('@google/genai');

// Firebase
const admin = require('firebase-admin');

// =========================================================
// 0) CONFIG
// =========================================================
const PORT = process.env.PORT || 10000;

const TWITCH_CLIENT_ID = process.env.TWITCH_CLIENT_ID;
const TWITCH_CLIENT_SECRET = process.env.TWITCH_CLIENT_SECRET;
const REDIRECT_URI = process.env.TWITCH_REDIRECT_URI;

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_MODEL = process.env.GEMINI_MODEL || 'gemini-2.5-flash';

// Cron snapshots
const ENABLE_CRON = (process.env.ENABLE_CRON || 'true').toLowerCase() !== 'false';
const SNAPSHOT_EVERY_MIN = Math.max(1, parseInt(process.env.SNAPSHOT_EVERY_MIN || '5', 10));

// Hard guard: √©viter de proposer des "mastodontes"
const DEFAULT_MAX_VIEWERS = Math.max(1, parseInt(process.env.DEFAULT_MAX_VIEWERS || '100', 10));
const DEFAULT_MIN_VIEWERS = Math.max(0, parseInt(process.env.DEFAULT_MIN_VIEWERS || '0', 10));

// =========================================================
// 1) INIT APP
// =========================================================
const app = express();
const server = http.createServer(app);

app.use(cors());
app.use(bodyParser.json({ limit: '1mb' }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname)));

// =========================================================
// 2) FIREBASE INIT
// =========================================================
let serviceAccount = null;

if (process.env.FIREBASE_SERVICE_KEY) {
  try {
    let rawJson = process.env.FIREBASE_SERVICE_KEY;
    if ((rawJson.startsWith("'") && rawJson.endsWith("'")) || (rawJson.startsWith('"') && rawJson.endsWith('"'))) {
      rawJson = rawJson.slice(1, -1);
    }
    rawJson = rawJson
      .replace(/\\r\\n/g, '\\n')
      .replace(/\\n/g, '\\n')
      .replace(/\\r/g, '\\n');
    serviceAccount = JSON.parse(rawJson);
  } catch (error) {
    console.error('‚ùå Erreur JSON Firebase:', error.message);
  }
} else {
  try { serviceAccount = require('./serviceAccountKey.json'); } catch (_) {}
}

try {
  if (serviceAccount) {
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      projectId: serviceAccount.project_id
    });
    console.log('‚úÖ [FIREBASE] connect√© (service account).');
  } else {
    admin.initializeApp();
    console.log('‚úÖ [FIREBASE] init default.');
  }
} catch (e) {
  console.error('‚ùå [FIREBASE] init:', e.message);
}

const db = admin.firestore();
try {
  if (serviceAccount) {
    db.settings({ projectId: serviceAccount.project_id, ignoreUndefinedProperties: true });
  } else {
    db.settings({ ignoreUndefinedProperties: true });
  }
} catch (_) {}

// =========================================================
// 3) IA INIT
// =========================================================
let aiClient = null;
if (GEMINI_API_KEY) {
  try {
    aiClient = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
    console.log('‚úÖ [IA] Gemini pr√™t.');
  } catch (e) {
    console.error('‚ùå [IA] init:', e.message);
  }
}

async function runGeminiAnalysis(prompt) {
  if (!aiClient) {
    return { success: false, html_response: "<p style='color:red;'>‚ùå IA non initialis√©e.</p>" };
  }
  try {
    const response = await aiClient.models.generateContent({
      model: GEMINI_MODEL,
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      config: {
        systemInstruction:
          "Tu es un coach Twitch data. R√©ponds UNIQUEMENT en HTML simple (<p>, <h4>, <ul>, <li>, <strong>). " +
          "Pas de markdown, pas de backticks. Sois clair, concret et actionnable."
      }
    });
    const text = response.candidates?.[0]?.content?.parts?.[0]?.text || "";
    return { success: true, html_response: text };
  } catch (e) {
    console.error("‚ùå Erreur IA:", e.message);
    return { success: false, html_response: `<p style='color:red;'>‚ùå Erreur IA: ${e.message}</p>` };
  }
}

// =========================================================
// 4) SOCKET.IO (websocket only => stop spam)
// =========================================================
const io = new Server(server, {
  cors: { origin: true, methods: ['GET', 'POST'] },
  transports: ['websocket'],
  allowUpgrades: false,
  pingInterval: 25000,
  pingTimeout: 20000
});

io.on('connection', (socket) => {
  console.log('üîå [SOCKET] client connected', socket.id);

  socket.on('chat message', (msg) => {
    const safe = {
      user: String(msg?.user || 'Anon').slice(0, 40),
      text: String(msg?.text || '').slice(0, 500)
    };
    if (!safe.text) return;
    io.emit('chat message', safe);
  });

  socket.on('disconnect', (reason) => {
    console.log('üîå [SOCKET] client disconnected', socket.id, reason);
  });
});

// =========================================================
// 5) HELPERS & CACHE
// =========================================================
const CACHE = {
  twitchTokens: { app: null },
  twitchUser: null,
  boostedStream: null,
  globalStreamRotation: { streams: [], currentIndex: 0, lastFetchTime: 0, fetchCooldown: 3 * 60 * 1000 }
};

function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

function yyyy_mm_dd_from_ms(ms) {
  const d = new Date(ms);
  const yyyy = d.getUTCFullYear();
  const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
  const dd = String(d.getUTCDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}

function computeGrowthScore({ avgViewers = 0, growthPct = 0, volatility = 0, hoursPerWeek = 0 }) {
  const logPart = Math.log10(avgViewers + 1) * 22;
  const growthPart = clamp(growthPct, -50, 200) * 0.22;
  const volPenalty = clamp(volatility, 0, 200) * 0.18;
  const hoursPart = clamp(hoursPerWeek, 0, 80) * 0.25;
  const raw = 15 + logPart + growthPart + hoursPart - volPenalty;
  return Math.round(clamp(raw, 0, 100));
}

async function getTwitchToken() {
  if (CACHE.twitchTokens.app && CACHE.twitchTokens.app.expiry > Date.now()) {
    return CACHE.twitchTokens.app.access_token;
  }
  try {
    const res = await fetch(
      `https://id.twitch.tv/oauth2/token?client_id=${TWITCH_CLIENT_ID}&client_secret=${TWITCH_CLIENT_SECRET}&grant_type=client_credentials`,
      { method: 'POST' }
    );
    const data = await res.json();
    if (!data.access_token) return null;

    CACHE.twitchTokens.app = {
      access_token: data.access_token,
      expiry: Date.now() + (data.expires_in * 1000) - 300000
    };
    return data.access_token;
  } catch (e) {
    return null;
  }
}

async function twitchAPI(endpoint, token = null) {
  const accessToken = token || await getTwitchToken();
  if (!accessToken) throw new Error("No Token.");

  const res = await fetch(`https://api.twitch.tv/helix/${endpoint}`, {
    headers: {
      'Client-ID': TWITCH_CLIENT_ID,
      'Authorization': `Bearer ${accessToken}`
    }
  });

  if (res.status === 401) {
    CACHE.twitchTokens.app = null;
    throw new Error("Token expir√©.");
  }
  return res.json();
}

// =========================================================
// 6) UI ROUTE
// =========================================================
app.get('/', (req, res) => {
  const candidates = [process.env.UI_FILE, 'NicheOptimizer.html'].filter(Boolean);
  const found = candidates.find(f => fs.existsSync(path.join(__dirname, f)));
  if (!found) return res.status(500).send('UI introuvable sur le serveur.');
  return res.sendFile(path.join(__dirname, found));
});

// =========================================================
// 7) STATUS ROUTES
// =========================================================
app.get('/firebase_status', (req, res) => {
  try {
    res.json({
      connected: !!db && admin.apps.length > 0,
      hasServiceAccount: !!serviceAccount
    });
  } catch (e) {
    res.json({ connected: false, error: e.message });
  }
});

// =========================================================
// 8) AUTH ROUTES
// =========================================================
app.get('/twitch_auth_start', (req, res) => {
  const state = crypto.randomBytes(16).toString('hex');
  const url =
    `https://id.twitch.tv/oauth2/authorize?client_id=${TWITCH_CLIENT_ID}` +
    `&redirect_uri=${encodeURIComponent(REDIRECT_URI)}` +
    `&response_type=code&scope=user:read:follows&state=${state}`;

  // secure cookie ok in prod https; en local, si besoin, mettre secure:false
  res.cookie('twitch_state', state, { httpOnly: true, secure: true, maxAge: 600000 });
  res.redirect(url);
});

app.get('/twitch_auth_callback', async (req, res) => {
  const { code, state } = req.query;
  if (state !== req.cookies.twitch_state) return res.send("Erreur Auth.");

  try {
    const tokenRes = await fetch('https://id.twitch.tv/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        client_id: TWITCH_CLIENT_ID,
        client_secret: TWITCH_CLIENT_SECRET,
        code,
        grant_type: 'authorization_code',
        redirect_uri: REDIRECT_URI
      })
    });

    const tokenData = await tokenRes.json();
    if (!tokenData.access_token) return res.send("Erreur Token.");

    const userRes = await twitchAPI('users', tokenData.access_token);
    const user = userRes.data?.[0];
    if (!user) return res.send("Erreur User.");

    CACHE.twitchUser = {
      display_name: user.display_name,
      id: user.id,
      profile_image_url: user.profile_image_url || null,
      access_token: tokenData.access_token,
      expiry: Date.now() + (tokenData.expires_in * 1000)
    };

    res.send("<script>window.close();</script>");
  } catch (_) {
    res.send("Erreur Serveur.");
  }
});

app.post('/twitch_logout', (req, res) => {
  CACHE.twitchUser = null;
  res.json({ success: true });
});

app.get('/twitch_user_status', (req, res) => {
  if (CACHE.twitchUser && CACHE.twitchUser.expiry > Date.now()) {
    return res.json({
      is_connected: true,
      display_name: CACHE.twitchUser.display_name,
      profile_image_url: CACHE.twitchUser.profile_image_url || null
    });
  }
  res.json({ is_connected: false });
});

// =========================================================
// 9) STREAMS ROUTES
// =========================================================
app.get('/followed_streams', async (req, res) => {
  if (!CACHE.twitchUser) return res.status(401).json({ success: false });

  try {
    const data = await twitchAPI(
      `streams/followed?user_id=${CACHE.twitchUser.id}`,
      CACHE.twitchUser.access_token
    );
    return res.json({
      success: true,
      streams: (data.data || []).map(s => ({
        user_id: s.user_id,
        user_name: s.user_name,
        user_login: s.user_login,
        viewer_count: s.viewer_count,
        game_id: s.game_id || null,
        game_name: s.game_name || null,
        title: s.title || null,
        thumbnail_url: s.thumbnail_url
      }))
    });
  } catch (e) {
    return res.status(500).json({ success: false, error: e.message });
  }
});

// ‚úÖ front l‚Äôutilise
app.post('/stream_info', async (req, res) => {
  const channel = String(req.body?.channel || '').trim().toLowerCase();
  if (!channel || channel === 'twitch') return res.json({ success: false });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(channel)}`);
    if (!uRes.data?.length) return res.json({ success: false });

    const userId = uRes.data[0].id;
    const sRes = await twitchAPI(`streams?user_id=${encodeURIComponent(userId)}`);
    return res.json({ success: true, stream: sRes.data?.[0] || null }); // null => offline
  } catch (e) {
    return res.json({ success: false, error: e.message });
  }
});

// =========================================================
// 10) ROTATION & BOOST
// =========================================================
async function refreshGlobalStreamList() {
  const now = Date.now();
  const rot = CACHE.globalStreamRotation;

  if (now - rot.lastFetchTime < rot.fetchCooldown && rot.streams.length > 0) return;

  try {
    const data = await twitchAPI(`streams?language=fr&first=100`);
    const suitable = (data.data || []).filter(s => {
      const v = Number(s.viewer_count || 0);
      return v >= DEFAULT_MIN_VIEWERS && v <= DEFAULT_MAX_VIEWERS;
    });

    const fallback = (data.data || []).slice(-10);
    const list = suitable.length ? suitable : fallback;

    rot.streams = list.sort(() => 0.5 - Math.random()).map(s => ({
      channel: s.user_login,
      viewers: s.viewer_count || 0,
      game_id: s.game_id || null,
      game_name: s.game_name || null
    }));
    rot.currentIndex = 0;
    rot.lastFetchTime = now;
  } catch (e) {
    console.error("Erreur refresh streams:", e.message);
  }
}

app.get('/get_default_stream', async (req, res) => {
  const now = Date.now();
  let boost = null;

  try {
    const q = await db.collection('boosts')
      .where('endTime', '>', now)
      .orderBy('endTime', 'desc')
      .limit(1)
      .get();

    if (!q.empty) {
      boost = q.docs[0].data();
      CACHE.boostedStream = boost;
    }
  } catch (_) {
    if (CACHE.boostedStream && CACHE.boostedStream.endTime > now) boost = CACHE.boostedStream;
  }

  if (boost) {
    return res.json({ success: true, channel: boost.channel, mode: 'BOOST', message: `‚ö° BOOST ACTIF` });
  }

  await refreshGlobalStreamList();
  const rot = CACHE.globalStreamRotation;
  if (!rot.streams.length) return res.json({ success: true, channel: 'twitch', mode: 'FALLBACK' });

  const cur = rot.streams[rot.currentIndex];
  return res.json({ success: true, channel: cur.channel, mode: 'AUTO', viewers: cur.viewers, game_name: cur.game_name || null });
});

app.post('/cycle_stream', async (req, res) => {
  const direction = String(req.body?.direction || 'next');

  if (CACHE.boostedStream && CACHE.boostedStream.endTime > Date.now()) {
    return res.json({ success: false, error: 'boost_active' });
  }

  await refreshGlobalStreamList();
  const rot = CACHE.globalStreamRotation;
  if (!rot.streams.length) return res.json({ success: false });

  if (direction === 'next') rot.currentIndex = (rot.currentIndex + 1) % rot.streams.length;
  else rot.currentIndex = (rot.currentIndex - 1 + rot.streams.length) % rot.streams.length;

  return res.json({ success: true, channel: rot.streams[rot.currentIndex].channel });
});

app.post('/stream_boost', async (req, res) => {
  const channel = String(req.body?.channel || '').trim().toLowerCase();
  const minutes = clamp(parseInt(req.body?.minutes || '15', 10), 1, 60);
  if (!channel) return res.status(400).json({ success: false });

  const now = Date.now();
  try {
    await db.collection('boosts').add({
      channel,
      startTime: now,
      endTime: now + minutes * 60 * 1000
    });

    CACHE.boostedStream = { channel, endTime: now + minutes * 60 * 1000 };

    res.json({ success: true, html_response: "<p style='color:green;'>‚úÖ Boost activ√© !</p>" });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur DB" });
  }
});

// =========================================================
// 11) STATS (Top games / languages) + GLOBAL INTRADAY
// =========================================================
app.get('/api/stats/top_games', async (req, res) => {
  try {
    const d = await twitchAPI('games/top?first=12');
    res.json({
      games: (d.data || []).map(g => ({
        id: g.id,
        name: g.name,
        box_art_url: g.box_art_url.replace('{width}', '180').replace('{height}', '240')
      }))
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.get('/api/stats/languages', async (req, res) => {
  try {
    const d = await twitchAPI('streams?first=100');
    const l = {};
    (d.data || []).forEach(s => {
      const key = String(s.language || '??');
      l[key] = (l[key] || 0) + 1;
    });

    const sorted = Object.keys(l)
      .map(k => ({ name: k.toUpperCase(), percent: l[k] }))
      .sort((a, b) => b.percent - a.percent)
      .slice(0, 5);

    res.json({ languages: sorted });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ‚úÖ intraday global 24h depuis stats_history
app.get('/api/stats/global_intraday', async (req, res) => {
  const hours = clamp(parseInt(req.query.hours || '24', 10), 1, 48);
  const since = Date.now() - hours * 60 * 60 * 1000;

  try {
    const snaps = await db.collection('stats_history')
      .where('timestamp_ms', '>=', since)
      .orderBy('timestamp_ms', 'asc')
      .get();

    if (snaps.empty) {
      // fallback live
      const live = await twitchAPI('streams?first=100');
      let v = 0; (live.data || []).forEach(s => v += (s.viewer_count || 0));
      return res.json({
        success: true,
        current_total_viewers: Math.floor(v * 3.8),
        current_channels_live: (live.data || []).length,
        series: { labels: ['maintenant'], values: [Math.floor(v * 3.8)] }
      });
    }

    const labels = [];
    const values = [];
    let curViewers = 0;
    let curChannels = 0;

    snaps.forEach(d => {
      const x = d.data();
      const ts = x.timestamp_ms || 0;
      const dt = new Date(ts);
      const label = `${String(dt.getHours()).padStart(2,'0')}:${String(dt.getMinutes()).padStart(2,'0')}`;
      labels.push(label);
      values.push(Number(x.total_viewers || 0));
      curViewers = Number(x.total_viewers || 0);
      curChannels = Number(x.channels_live || 0);
    });

    res.json({
      success: true,
      current_total_viewers: curViewers,
      current_channels_live: curChannels,
      series: { labels, values }
    });
  } catch (e) {
    res.status(500).json({ success: false, error: e.message });
  }
});

// Compat: certains fronts appellent /api/stats/global
app.get('/api/stats/global', async (req, res) => {
  try {
    const g = await db.collection('stats_history').orderBy('timestamp_ms', 'desc').limit(12).get();
    if (g.empty) {
      const live = await twitchAPI('streams?first=100');
      let v = 0; (live.data || []).forEach(s => v += (s.viewer_count || 0));
      return res.json({ success: true, total_viewers: Math.floor(v * 3.8), total_channels: '‚Äî', top_game_name: live.data?.[0]?.game_name || '‚Äî', history: { live: { labels: ['maintenant'], values: [Math.floor(v * 3.8)] } } });
    }

    const labels = [];
    const values = [];
    let latest = g.docs[0].data();
    g.docs.slice().reverse().forEach(doc => {
      const x = doc.data();
      const ts = x.timestamp_ms || 0;
      const dt = new Date(ts);
      labels.push(`${String(dt.getHours()).padStart(2,'0')}h${String(dt.getMinutes()).padStart(2,'0')}`);
      values.push(Number(x.total_viewers || 0));
    });

    res.json({
      success: true,
      total_viewers: Number(latest.total_viewers || 0),
      total_channels: Number(latest.channels_live || 0),
      top_game_name: latest.top_game || '‚Äî',
      history: { live: { labels, values } }
    });
  } catch (e) {
    res.status(500).json({ success: false, error: e.message });
  }
});

// =========================================================
// 12) RANDOM STREAMER (<=100 viewers) - global + par jeu
// =========================================================
async function pickRandomStreamFromList(streams, minV, maxV) {
  const pool = (streams || []).filter(s => {
    const v = Number(s.viewer_count || 0);
    return v >= minV && v <= maxV && s.user_login;
  });
  if (!pool.length) return null;
  return pool[Math.floor(Math.random() * pool.length)];
}

app.get('/api/streams/random_global', async (req, res) => {
  const language = String(req.query.language || 'fr').trim() || 'fr';
  const maxV = clamp(parseInt(req.query.max_viewers || String(DEFAULT_MAX_VIEWERS), 10), 1, 5000);
  const minV = clamp(parseInt(req.query.min_viewers || String(DEFAULT_MIN_VIEWERS), 10), 0, maxV);

  try {
    const data = await twitchAPI(`streams?first=100&language=${encodeURIComponent(language)}`);
    const picked = await pickRandomStreamFromList(data.data, minV, maxV);
    if (!picked) return res.json({ success: false, message: 'aucun_stream_correspondant' });

    // profil (pour avatar)
    let prof = null;
    try {
      const u = await twitchAPI(`users?login=${encodeURIComponent(picked.user_login)}`);
      prof = u.data?.[0] || null;
    } catch (_) {}

    return res.json({
      success: true,
      stream: {
        login: picked.user_login,
        display_name: picked.user_name,
        viewers: picked.viewer_count || 0,
        game_id: picked.game_id || null,
        game_name: picked.game_name || null,
        title: picked.title || null,
        thumbnail_url: picked.thumbnail_url || null,
        profile_image_url: prof?.profile_image_url || null
      }
    });
  } catch (e) {
    return res.status(500).json({ success: false, error: e.message });
  }
});

// par jeu : accepte game_id OU game (nom)
app.get('/api/streams/random_for_game', async (req, res) => {
  const maxV = clamp(parseInt(req.query.max_viewers || String(DEFAULT_MAX_VIEWERS), 10), 1, 5000);
  const minV = clamp(parseInt(req.query.min_viewers || String(DEFAULT_MIN_VIEWERS), 10), 0, maxV);
  const language = String(req.query.language || 'fr').trim() || 'fr';

  let gameId = String(req.query.game_id || '').trim();
  const gameName = String(req.query.game || '').trim();

  try {
    if (!gameId && gameName) {
      const gRes = await twitchAPI(`search/categories?query=${encodeURIComponent(gameName)}&first=1`);
      gameId = gRes.data?.[0]?.id ? String(gRes.data[0].id) : '';
    }
    if (!gameId) return res.status(400).json({ success: false, message: 'game_id_ou_nom_requis' });

    const sRes = await twitchAPI(`streams?game_id=${encodeURIComponent(gameId)}&first=100&language=${encodeURIComponent(language)}`);
    const picked = await pickRandomStreamFromList(sRes.data, minV, maxV);
    if (!picked) return res.json({ success: false, message: 'aucun_stream_correspondant' });

    let prof = null;
    try {
      const u = await twitchAPI(`users?login=${encodeURIComponent(picked.user_login)}`);
      prof = u.data?.[0] || null;
    } catch (_) {}

    return res.json({
      success: true,
      stream: {
        login: picked.user_login,
        display_name: picked.user_name,
        viewers: picked.viewer_count || 0,
        game_id: picked.game_id || null,
        game_name: picked.game_name || null,
        title: picked.title || null,
        thumbnail_url: picked.thumbnail_url || null,
        profile_image_url: prof?.profile_image_url || null
      }
    });
  } catch (e) {
    return res.status(500).json({ success: false, error: e.message });
  }
});

// Optionnel: recherche de jeux (utile pour une pop-up type Netflix)
app.get('/api/games/search', async (req, res) => {
  const q = String(req.query.q || '').trim();
  const first = clamp(parseInt(req.query.first || '12', 10), 1, 50);
  if (!q) return res.status(400).json({ success: false, message: 'q_requis' });

  try {
    const gRes = await twitchAPI(`search/categories?query=${encodeURIComponent(q)}&first=${first}`);
    return res.json({
      success: true,
      games: (gRes.data || []).map(g => ({
        id: g.id,
        name: g.name,
        box_art_url: (g.box_art_url || '').replace('{width}', '180').replace('{height}', '240')
      }))
    });
  } catch (e) {
    return res.status(500).json({ success: false, error: e.message });
  }
});

// =========================================================
// 13) SCAN / RAID (compat)
// =========================================================
app.post('/scan_target', async (req, res) => {
  const query = String(req.body?.query || '').trim().toLowerCase();
  if (!query) return res.status(400).json({ success: false });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(query)}`);
    if (uRes.data?.length) {
      const u = uRes.data[0];

      let channelInfo = {};
      try {
        const cRes = await twitchAPI(`channels?broadcaster_id=${u.id}`);
        if (cRes.data?.length) channelInfo = cRes.data[0];
      } catch (_) {}

      let streamInfo = null;
      try {
        const sRes = await twitchAPI(`streams?user_id=${u.id}`);
        if (sRes.data?.length) streamInfo = sRes.data[0];
      } catch (_) {}

      const isLive = !!streamInfo;

      const uData = {
        id: u.id,
        login: u.login,
        display_name: u.display_name,
        profile_image_url: u.profile_image_url,
        description: u.description || "Aucune bio.",
        created_at: new Date(u.created_at).toLocaleDateString('fr-FR'),
        game_name: channelInfo.game_name || "Aucun jeu d√©fini",
        title: channelInfo.title || "Aucun titre",
        tags: channelInfo.tags ? channelInfo.tags.slice(0, 3).join(', ') : "Aucun",
        language: channelInfo.broadcaster_language || "fr",
        view_count: u.view_count || 0,
        is_live: isLive,
        viewer_count: isLive ? streamInfo.viewer_count : 0
      };

      return res.json({ success: true, type: 'user', user_data: uData });
    }

    // fallback game
    const gRes = await twitchAPI(`search/categories?query=${encodeURIComponent(query)}&first=1`);
    if (gRes.data?.length) {
      const g = gRes.data[0];
      const sRes = await twitchAPI(`streams?game_id=${g.id}&first=20`);
      const total = (sRes.data || []).reduce((a, b) => a + (b.viewer_count || 0), 0);

      const gData = {
        id: g.id,
        name: g.name,
        box_art_url: g.box_art_url.replace('{width}', '180').replace('{height}', '240'),
        total_viewers: total
      };

      return res.json({ success: true, type: 'game', game_data: gData });
    }

    res.json({ success: false });
  } catch (e) {
    res.status(500).json({ success: false, error: e.message });
  }
});

app.post('/start_raid', async (req, res) => {
  const game = String(req.body?.game || '').trim();
  const maxViewers = clamp(parseInt(req.body?.max_viewers || String(DEFAULT_MAX_VIEWERS), 10), 1, 5000);
  const minViewers = clamp(parseInt(req.body?.min_viewers || String(DEFAULT_MIN_VIEWERS), 10), 0, maxViewers);

  if (!game) return res.status(400).json({ success: false });

  try {
    const gRes = await twitchAPI(`search/categories?query=${encodeURIComponent(game)}&first=1`);
    if (!gRes.data?.length) return res.json({ success: false });

    const sRes = await twitchAPI(`streams?game_id=${gRes.data[0].id}&first=100&language=fr`);
    const pool = (sRes.data || [])
      .filter(s => {
        const v = Number(s.viewer_count || 0);
        return v >= minViewers && v <= maxViewers;
      })
      .sort((a, b) => (b.viewer_count || 0) - (a.viewer_count || 0));

    const target = pool[0] || null;
    if (!target) return res.json({ success: false });

    return res.json({
      success: true,
      target: {
        name: target.user_name,
        login: target.user_login,
        viewers: target.viewer_count,
        thumbnail_url: target.thumbnail_url.replace('{width}', '320').replace('{height}', '180'),
        game: target.game_name
      }
    });
  } catch (e) {
    res.status(500).json({ success: false, error: e.message });
  }
});

// =========================================================
// 14) BEST TIME (IA)
// =========================================================
app.post('/analyze_schedule', async (req, res) => {
  const game = String(req.body?.game || '').trim();
  if (!game) return res.status(400).json({ success:false, html_response:'<p style="color:red;">‚ùå Nom du jeu manquant</p>' });

  try {
    const gRes = await twitchAPI(`search/categories?query=${encodeURIComponent(game)}&first=1`);
    if (!gRes.data?.length) {
      return res.json({ success:false, html_response:`<p style="color:red;"><strong>‚ùå Jeu "${game}" non trouv√©</strong></p>` });
    }

    const gameName = gRes.data[0].name;
    const gameId = gRes.data[0].id;

    const sRes = await twitchAPI(`streams?game_id=${gameId}&first=100&language=fr`);
    const totalViewers = (sRes.data || []).reduce((a, b) => a + (b.viewer_count||0), 0);
    const channelCount = (sRes.data || []).length;
    const avgViewers = Math.round(totalViewers / (channelCount || 1));

    const prompt = `Tu es expert en optimisation streaming Twitch pour le jeu "${gameName}".

Donn√©es du moment:
- Cha√Ænes live: ${channelCount}
- Viewers totaux: ${totalViewers}
- Moyenne viewers/cha√Æne: ${avgViewers}

R√©ponds en HTML STRICT (<h4>, <ul>, <li>, <p>, <strong>):
1) Saturation (faible/moyenne/haute) + explication courte
2) 3 cr√©neaux concrets (jour + heure) et pourquoi
3) Score niche 1..10 (et comment l'am√©liorer)
4) 1 action imm√©diate pour gagner des viewers.`;

    const aiResponse = await runGeminiAnalysis(prompt);
    return res.json({ success: aiResponse.success !== false, html_response: aiResponse.html_response || '<p style="color:red;">‚ùå Erreur IA</p>' });
  } catch (e) {
    return res.json({ success:false, html_response:`<p style="color:red;">‚ùå Erreur: ${e.message}</p>` });
  }
});

// =========================================================
// 15) ANALYTICS (daily + intraday) + ALERTS + GAMES/HOURS
// =========================================================
app.get('/api/analytics/channel_by_login/:login', async (req, res) => {
  const login = String(req.params.login || '').trim().toLowerCase();
  const days = clamp(parseInt(req.query.days || '30', 10), 1, 90);
  if (!login) return res.status(400).json({ success: false, message: 'login manquant' });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return res.json({ success: false, message: 'introuvable' });
    const channelId = String(uRes.data[0].id);

    const sinceKey = yyyy_mm_dd_from_ms(Date.now() - days * 24 * 60 * 60 * 1000);
    const snaps = await db.collection('channels').doc(channelId)
      .collection('daily_stats')
      .where('day', '>=', sinceKey)
      .orderBy('day', 'asc')
      .get();

    if (snaps.empty) return res.json({ success: false, message: 'pas_de_donnees', channel_id: channelId });

    const seriesDays = snaps.docs.map(d => d.data());
    const labels = seriesDays.map(x => x.day);
    const values = seriesDays.map(x => Number(x.avg_viewers || 0));

    const avg = Math.round(values.reduce((a,b)=>a+b,0) / (values.length || 1));
    const peak = Math.max(...seriesDays.map(x => Number(x.peak_viewers || 0)));

    const first = values[0] || 0;
    const last = values[values.length - 1] || 0;
    const growthPct = first > 0 ? Math.round(((last - first) / first) * 100) : (last > 0 ? 100 : 0);

    const mean = avg;
    const variance = values.reduce((a, v) => a + Math.pow(v - mean, 2), 0) / (values.length || 1);
    const volatility = Math.round(Math.sqrt(variance));

    const totalMinutes = seriesDays.reduce((a, x) => a + Number(x.minutes_live_est || 0), 0);
    const hoursPerWeek = Math.round((totalMinutes / 60) / (days / 7));

    const growthScore = computeGrowthScore({ avgViewers: avg, growthPct, volatility, hoursPerWeek });

    return res.json({
      success: true,
      channel_id: channelId,
      login,
      kpis: {
        avg_viewers: avg,
        peak_viewers: peak,
        growth_percent: growthPct,
        volatility,
        hours_per_week_est: hoursPerWeek,
        growth_score: growthScore,
        days: labels.length
      },
      series: { labels, values }
    });
  } catch (e) {
    return res.status(500).json({ success: false, message: e.message });
  }
});

// intraday (24h) depuis hourly_stats + KPIs
app.get('/api/analytics/channel_intraday_by_login/:login', async (req, res) => {
  const login = String(req.params.login || '').trim().toLowerCase();
  const hours = clamp(parseInt(req.query.hours || '24', 10), 1, 48);
  if (!login) return res.status(400).json({ success:false, message:'login manquant' });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return res.json({ success:false, message:'introuvable' });
    const channelId = String(uRes.data[0].id);

    const since = Date.now() - hours * 60 * 60 * 1000;

    const q = await db.collection('channels').doc(channelId)
      .collection('hourly_stats')
      .where('timestamp', '>=', since)
      .get();

    if (q.empty) return res.json({ success:false, message:'pas_de_donnees', channel_id: channelId });

    const points = q.docs.map(d => d.data()).sort((a,b)=> (a.timestamp||0) - (b.timestamp||0));
    const labels = [];
    const values = [];

    let sum = 0;
    let peak = 0;
    const viewersArr = [];

    let current_game_id = null;
    let current_game_name = null;

    points.forEach(p => {
      const ts = p.timestamp || 0;
      const dt = new Date(ts);
      labels.push(`${String(dt.getHours()).padStart(2,'0')}:${String(dt.getMinutes()).padStart(2,'0')}`);
      const v = Number(p.viewers || 0);
      values.push(v);
      viewersArr.push(v);
      sum += v;
      if (v > peak) peak = v;
      if (p.game_id) { current_game_id = p.game_id; current_game_name = p.game_name || null; }
    });

    const avg = Math.round(sum / (viewersArr.length || 1));
    const first = viewersArr[0] || 0;
    const last = viewersArr[viewersArr.length - 1] || 0;
    const growth = first > 0 ? Math.round(((last - first) / first) * 100) : (last>0 ? 100 : 0);

    const mean = avg;
    const variance = viewersArr.reduce((a, v) => a + Math.pow(v - mean, 2), 0) / (viewersArr.length || 1);
    const volatility = Math.round(Math.sqrt(variance));

    let hoursPerWeek = null;
    try {
      const ds = await db.collection('channels').doc(channelId).collection('daily_stats')
        .orderBy('day','desc').limit(14).get();
      if (!ds.empty) {
        const series = ds.docs.map(d=>d.data());
        const minutes = series.reduce((a,x)=>a+(x.minutes_live_est||0),0);
        const days = series.length || 1;
        hoursPerWeek = Math.round((minutes/60) / (days/7));
      }
    } catch(_) {}

    const growth_score = computeGrowthScore({ avgViewers: avg, growthPct: growth, volatility, hoursPerWeek: hoursPerWeek || 0 });

    return res.json({
      success:true,
      channel_id: channelId,
      login,
      current_game_id,
      current_game_name,
      kpis:{
        avg_viewers: avg,
        peak_viewers: peak,
        growth_percent: growth,
        volatility,
        hours_per_week_est: hoursPerWeek,
        growth_score,
        samples: viewersArr.length
      },
      series:{ labels, values }
    });
  } catch (e) {
    return res.status(500).json({ success:false, message:e.message });
  }
});

// Alerts
async function saveAlert(channelId, dayKey, type, payload) {
  try {
    const ref = db.collection('alerts').doc(String(channelId))
      .collection('items').doc(`${dayKey}_${type}`);
    await ref.set({
      channel_id: String(channelId),
      day: dayKey,
      type,
      ...payload,
      created_at: admin.firestore.Timestamp.fromMillis(Date.now())
    }, { merge: true });
  } catch (e) {
    console.error("‚ùå [ALERT] saveAlert:", e.message);
  }
}

function computeGrowthScoreSimple({ avg_viewers=0, peak_viewers=0, growth_percent=0, minutes_live_est=0 } = {}) {
  const base = Math.log10(avg_viewers + 1) * 25;
  const peakBoost = Math.log10(peak_viewers + 1) * 10;
  const growthBoost = clamp(growth_percent, -50, 200) * 0.15;
  const cadence = Math.min(20, (minutes_live_est / 60) * 1.2);
  const raw = base + peakBoost + growthBoost + cadence;
  return Math.max(0, Math.min(100, Math.round(raw)));
}

async function generateAlertsForLogin(login, days=30) {
  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return { success:false, message:"introuvable" };
    const user = uRes.data[0];
    const channelId = String(user.id);

    const snaps = await db.collection('channels').doc(channelId)
      .collection('daily_stats').orderBy('day', 'desc').limit(days).get();
    if (snaps.empty) return { success:false, message:"pas de daily_stats" };

    const series = snaps.docs.map(d => d.data()).reverse();
    const first = series[0]?.avg_viewers || 0;
    const last = series[series.length-1]?.avg_viewers || 0;
    const growth_percent = first > 0 ? Math.round(((last-first)/first)*100) : (last>0?100:0);

    const avg = Math.round(series.reduce((a,x)=>a+(x.avg_viewers||0),0)/series.length);
    const peak = Math.max(...series.map(x=>x.peak_viewers||0));
    const minutes_live_est = Math.round(series.reduce((a,x)=>a+(x.minutes_live_est||0),0)/series.length);

    const growth_score = computeGrowthScoreSimple({ avg_viewers: avg, peak_viewers: peak, growth_percent, minutes_live_est });
    const dayKey = yyyy_mm_dd_from_ms(Date.now());

    if (growth_percent >= 25 && growth_score >= 60) {
      await saveAlert(channelId, dayKey, "acceleration", {
        title: "üöÄ Acc√©l√©ration d√©tect√©e",
        message: `Ta moyenne grimpe (+${growth_percent}%). Double les formats qui performent: titres clairs, clips, rediff cibl√©es.`,
        score: growth_score
      });
    }
    if (avg < 10 && minutes_live_est >= 180) {
      await saveAlert(channelId, dayKey, "format", {
        title: "üß™ Ajuste ton format",
        message: "Tu streams longtemps mais la moyenne reste basse: intro plus courte, objectif clair, cat√©gories moins satur√©es.",
        score: growth_score
      });
    }

    if (aiClient) {
      const prompt = `Pour ${user.display_name} (${login}), propose 1 alerte tr√®s courte, actionnable, pour aujourd'hui.
Donn√©es: moyenne=${avg}, pic=${peak}, croissance=${growth_percent}%, minutes live estim√©es=${minutes_live_est}, score=${growth_score}/100.`;
      const out = await runGeminiAnalysis(prompt);
      await saveAlert(channelId, dayKey, "ia", {
        title: "üí° Suggestion IA",
        message: (out.html_response || '').replace(/<\/?[^>]+(>|$)/g, '').slice(0, 320),
        score: growth_score
      });
    }

    return { success:true, channel_id: channelId, growth_score, growth_percent, avg_viewers: avg, peak_viewers: peak };
  } catch (e) {
    return { success:false, error: e.message };
  }
}

app.get('/api/alerts/channel_by_login/:login', async (req, res) => {
  const login = String(req.params.login||'').trim().toLowerCase();
  const limit = clamp(parseInt(req.query.limit||'10',10), 1, 50);
  if (!login) return res.status(400).json({ success:false, error:"login manquant" });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return res.json({ success:false, error:"introuvable" });
    const channelId = String(uRes.data[0].id);

    const q = await db.collection('alerts').doc(channelId)
      .collection('items').orderBy('created_at','desc').limit(limit).get();

    const items = q.docs.map(d => d.data());
    return res.json({ success:true, channel_id: channelId, items });
  } catch (e) {
    return res.status(500).json({ success:false, error:e.message });
  }
});

app.post('/api/alerts/generate', async (req, res) => {
  const login = String(req.body?.login || '').trim().toLowerCase();
  const days = clamp(parseInt(req.body?.days || '30', 10), 1, 180);
  if (!login) return res.status(400).json({ success:false, error:"login manquant" });
  const r = await generateAlertsForLogin(login, days);
  return res.json(r);
});

// Games hours
app.get('/api/games/hours', async (req, res) => {
  const gameId = String(req.query.game_id || '').trim();
  const days = clamp(parseInt(req.query.days || '7', 10), 1, 30);
  if (!gameId) return res.status(400).json({ success:false, error:"game_id requis" });

  try {
    const since = Date.now() - days*24*60*60*1000;
    const snaps = await db.collection('games').doc(gameId)
      .collection('hourly_stats').where('timestamp','>=', since).get();

    const hours = Array.from({length:24},(_,h)=>({ hour:h, total_viewers:0, channels: new Set(), samples:0 }));
    snaps.forEach(d => {
      const x = d.data();
      const ts = x.timestamp || 0;
      const h = new Date(ts).getUTCHours();
      const viewers = Number(x.viewers || 0);
      hours[h].total_viewers += viewers;
      if (x.channel_id) hours[h].channels.add(String(x.channel_id));
      hours[h].samples += 1;
    });

    const out = hours.map(o => {
      const ch = o.channels.size;
      const avgPerChan = ch ? Math.round(o.total_viewers / ch) : 0;

      // scores "p√©dagogiques" (0..100) : plus c'est haut, plus c'est tendu (saturation)
      const saturation = ch ? Math.min(100, Math.round((ch / Math.max(1, avgPerChan)) * 35)) : 0;

      // discoverability : m√©lange simple (plus d'audience par cha√Æne + moins de concurrence => mieux)
      const discoverability = avgPerChan ? Math.min(100, Math.round((avgPerChan / (avgPerChan + ch)) * 200)) : 0;

      return {
        hour: o.hour,
        channels: ch,
        total_viewers: o.total_viewers,
        avg_viewers_per_channel: avgPerChan,
        saturation_score: saturation,
        discoverability_score: discoverability
      };
    });

    const best = [...out].sort((a,b)=> (b.discoverability_score - a.discoverability_score) || (b.total_viewers - a.total_viewers))[0];
    return res.json({ success:true, game_id: gameId, days, hours: out, best_hour_utc: best?.hour ?? null });
  } catch (e) {
    return res.status(500).json({ success:false, error:e.message });
  }
});

// IA reco
app.get('/api/ai/reco', async (req, res) => {
  const login = String(req.query.login || '').trim().toLowerCase();
  const days = clamp(parseInt(req.query.days || '30', 10), 7, 90);
  if (!login) return res.status(400).json({ success:false, html_response:"<p style='color:red;'>login requis</p>" });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return res.json({ success:false, html_response:"<p style='color:red;'>introuvable</p>" });
    const channelId = String(uRes.data[0].id);

    const sinceKey = yyyy_mm_dd_from_ms(Date.now() - days * 24 * 60 * 60 * 1000);
    const snaps = await db.collection('channels').doc(channelId)
      .collection('daily_stats').where('day','>=', sinceKey).orderBy('day','asc').get();

    if (snaps.empty) return res.json({ success:false, html_response:"<p style='color:red;'>Pas assez de donn√©es daily_stats.</p>" });

    const series = snaps.docs.map(d => d.data());
    const values = series.map(x=>Number(x.avg_viewers||0));
    const avg = Math.round(values.reduce((a,b)=>a+b,0)/(values.length||1));
    const peak = Math.max(...series.map(x=>Number(x.peak_viewers||0)));

    const first = values[0]||0;
    const last = values[values.length-1]||0;
    const growthPct = first>0 ? Math.round(((last-first)/first)*100) : (last>0?100:0);

    const mean = avg;
    const variance = values.reduce((a, v) => a + Math.pow(v - mean, 2), 0) / (values.length || 1);
    const volatility = Math.round(Math.sqrt(variance));

    const totalMinutes = series.reduce((a,x)=>a+Number(x.minutes_live_est||0),0);
    const hoursPerWeek = Math.round((totalMinutes/60)/(days/7));
    const growthScore = computeGrowthScore({ avgViewers: avg, growthPct, volatility, hoursPerWeek });

    const prompt = `Tu es un coach Twitch DATA-DRIVEN. R√©ponds UNIQUEMENT en HTML (<h4>, <ul>, <li>, <p>, <strong>).

DONN√âES:
- moyenne viewers: ${avg}
- pic viewers: ${peak}
- croissance: ${growthPct}%
- volatilit√©: ${volatility}
- heures/sem estim√©es: ${hoursPerWeek}
- score croissance: ${growthScore}/100

OBJECTIF:
- 5 recommandations concr√®tes (avec "quoi faire aujourd'hui")
- 3 exp√©riences √† tester semaine prochaine (format/horaires/titre/cat√©gorie)
- 1 phrase motivante r√©aliste.`;

    const ai = await runGeminiAnalysis(prompt);
    return res.json(ai);
  } catch (e) {
    return res.status(500).json({ success:false, html_response:`<p style='color:red;'>${e.message}</p>` });
  }
});

// CO-STREAM
app.get('/api/costream/best', async (req, res) => {
  const login = String(req.query.login || '').trim().toLowerCase();
  if (!login) return res.status(400).json({ success:false, message:'login manquant' });

  try {
    const uRes = await twitchAPI(`users?login=${encodeURIComponent(login)}`);
    if (!uRes.data?.length) return res.json({ success:false, message:'Cha√Æne introuvable' });
    const me = uRes.data[0];

    const sMe = await twitchAPI(`streams?user_id=${me.id}`);
    const myStream = sMe.data?.[0] || null;

    const gameId = myStream?.game_id || null;
    const gameName = myStream?.game_name || null;
    const myViewers = Number(myStream?.viewer_count || 50);

    if (!gameId) return res.json({ success:false, message:'Cha√Æne offline (jeu inconnu). Lance un live.' });

    const sGame = await twitchAPI(`streams?game_id=${encodeURIComponent(gameId)}&first=100&language=fr`);
    const candidatesRaw = (sGame.data || []).filter(s => s.user_login && s.user_login.toLowerCase() !== login);

    if (!candidatesRaw.length) return res.json({ success:false, message:'Aucun co-streamer FR live sur ce jeu.' });

    const target = Math.max(5, myViewers);
    const scored = candidatesRaw.map(s=>{
      const v = Number(s.viewer_count || 0);
      const diff = Math.abs(v - target);
      const score = Math.max(1, 100 - diff);
      return { s, score };
    }).sort((a,b)=>b.score-a.score);

    const bestS = scored[0].s;
    let prof = null;
    try {
      const bestProfile = await twitchAPI(`users?login=${encodeURIComponent(bestS.user_login)}`);
      prof = bestProfile.data?.[0] || null;
    } catch(_) {}

    const candidates = scored.slice(0, 8).map(x=>({
      login: x.s.user_login,
      display_name: x.s.user_name,
      score: x.score
    }));

    return res.json({
      success:true,
      best: {
        login: bestS.user_login,
        display_name: bestS.user_name,
        profile_image_url: prof?.profile_image_url || null,
        score: scored[0].score,
        why: `M√™me jeu (${gameName || bestS.game_name}) + audience proche (${bestS.viewer_count} vs ~${target}).`
      },
      candidates
    });
  } catch (e) {
    return res.status(500).json({ success:false, message:e.message });
  }
});

// =========================================================
// 16) CRON SNAPSHOTS + ROLLUPS (daily_stats + games hourly_stats)
// =========================================================
async function upsertChannelMetaFromStream(stream, nowMs) {
  const ref = db.collection('channels').doc(String(stream.user_id));
  try {
    const snap = await ref.get();
    const payload = {
      login: stream.user_login || null,
      display_name: stream.user_name || null,
      language: stream.language || null,
      current_game_id: stream.game_id || null,
      current_game_name: stream.game_name || null,
      last_seen_live: admin.firestore.Timestamp.fromMillis(nowMs)
    };
    if (!snap.exists) payload.first_seen = admin.firestore.Timestamp.fromMillis(nowMs);
    await ref.set(payload, { merge: true });
  } catch (e) {
    console.error("‚ùå [FIRESTORE] upsertChannelMetaFromStream:", e.message);
  }
}

async function upsertGameMeta(gameId, gameName) {
  if (!gameId) return;
  try {
    await db.collection('games').doc(String(gameId)).set({
      name: gameName || null,
      last_seen: admin.firestore.Timestamp.fromMillis(Date.now())
    }, { merge: true });
  } catch (_) {}
}

async function collectAnalyticsSnapshot() {
  const now = Date.now();
  const dayKey = yyyy_mm_dd_from_ms(now);
  const inc = admin.firestore.FieldValue.increment;

  try {
    const data = await twitchAPI('streams?first=100&language=fr');
    const streams = data?.data || [];
    let totalViewers = 0;

    let batch = db.batch();
    let ops = 0;
    const commitIfNeeded = async () => {
      if (ops >= 430) { await batch.commit(); batch = db.batch(); ops = 0; }
    };

    for (const s of streams) {
      totalViewers += (s.viewer_count || 0);

      await upsertChannelMetaFromStream(s, now);
      await upsertGameMeta(s.game_id, s.game_name);

      // intraday channel point
      const chRef = db.collection('channels').doc(String(s.user_id))
        .collection('hourly_stats').doc(String(now));

      batch.set(chRef, {
        timestamp: now,
        viewers: s.viewer_count || 0,
        game_id: s.game_id || null,
        game_name: s.game_name || null,
        title: s.title || null,
        language: s.language || null
      }, { merge: false });
      ops++; await commitIfNeeded();

      // games hourly_stats (pour /api/games/hours)
      if (s.game_id) {
        const gRef = db.collection('games').doc(String(s.game_id))
          .collection('hourly_stats').doc(`${now}_${s.user_id}`);
        batch.set(gRef, {
          timestamp: now,
          viewers: s.viewer_count || 0,
          channel_id: String(s.user_id),
          channel_login: s.user_login || null
        }, { merge: false });
        ops++; await commitIfNeeded();
      }

      // daily rollup per channel (accumul√©)
      const dRef = db.collection('channels').doc(String(s.user_id))
        .collection('daily_stats').doc(dayKey);

      batch.set(dRef, {
        day: dayKey,
        // cumuls (on stocke pour recalculer proprement)
        samples: inc(1),
        sum_viewers: inc(Number(s.viewer_count || 0)),
        peak_viewers: admin.firestore.FieldValue.maximum ? admin.firestore.FieldValue.maximum(Number(s.viewer_count || 0)) : undefined,
        minutes_live_est: inc(SNAPSHOT_EVERY_MIN),
        // meta
        last_game_id: s.game_id || null,
        last_game_name: s.game_name || null,
        updated_at: admin.firestore.Timestamp.fromMillis(now)
      }, { merge: true });
      ops++; await commitIfNeeded();
    }

    // global stats_history point
    const globalRef = db.collection('stats_history').doc(String(now));
    batch.set(globalRef, {
      timestamp: admin.firestore.Timestamp.fromMillis(now),
      timestamp_ms: now,
      total_viewers: totalViewers,
      channels_live: streams.length,
      top_game: streams[0]?.game_name || null
    }, { merge: false });
    ops++; await commitIfNeeded();

    await batch.commit();

    // post-process: recompute avg_viewers for daily_stats docs touched (simple, few docs)
    // On garde √ßa l√©ger: uniquement pour les streams dans le top 100 => max 100 docs.
    // (et √ßa reste "merge" => pas bloquant si √ßa rate)
    const updates = streams.map(async (s) => {
      const ref = db.collection('channels').doc(String(s.user_id)).collection('daily_stats').doc(dayKey);
      try {
        const snap = await ref.get();
        if (!snap.exists) return;
        const x = snap.data();
        const samples = Number(x.samples || 0);
        const sum = Number(x.sum_viewers || 0);
        const peak = Number(x.peak_viewers || 0);
        const avg = samples ? Math.round(sum / samples) : 0;
        await ref.set({ avg_viewers: avg, peak_viewers: peak }, { merge: true });
      } catch (_) {}
    });

    await Promise.allSettled(updates);

    console.log(`üìä [CRON] Snapshot saved: viewers=${totalViewers}, live=${streams.length}`);
  } catch (e) {
    console.error("‚ùå [CRON] Snapshot error:", e.message);
  }
}

// NOTE: FieldValue.maximum est r√©cent; si indispo, on fait un fallback sans max (on recalculera via post-process)
if (!admin.firestore.FieldValue.maximum) {
  // fallback: on ne set pas peak via max atomique
}

if (ENABLE_CRON) {
  console.log(`‚úÖ CRON ENABLED = true (every ${SNAPSHOT_EVERY_MIN}min)`);
  setInterval(collectAnalyticsSnapshot, SNAPSHOT_EVERY_MIN * 60 * 1000);
  collectAnalyticsSnapshot().catch(() => {});
} else {
  console.log(`‚ÑπÔ∏è CRON ENABLED = false`);
}

// =========================================================
// 17) START
// =========================================================
server.listen(PORT, () => {
  console.log(`\nüöÄ [SERVER] D√©marr√© sur http://localhost:${PORT}`);
  console.log("‚úÖ Routes pr√™tes");
  console.log(" - UI: / (NicheOptimizer.html)");
  console.log(" - /firebase_status");
  console.log(" - /stream_info");
  console.log(" - /api/stats/global_intraday (+ compat /api/stats/global)");
  console.log(" - /api/analytics/channel_intraday_by_login/:login");
  console.log(" - /api/streams/random_global  (<=100 viewers)");
  console.log(" - /api/streams/random_for_game (<=100 viewers)");
  console.log(` - CRON ENABLED = ${ENABLE_CRON ? 'true' : 'false'}`);
});
"""
Path("/mnt/data/app_FIXED.js").write_text(backend, encoding="utf-8")

# ---------- Patch the uploaded HTML without changing the visual ----------
html_path = Path("/mnt/data/NicheOptimizer.html")
orig_html = html_path.read_text(encoding="utf-8", errors="ignore")

# Injection blocks
style_block = r"""
<!-- STREAMER_HUB_HELP_STYLE_START -->
<style id="streamerHubHelpStyle">
/* Ajouts tr√®s discrets: tooltip + petit (i) sans casser ton visuel */
.sh-help {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  margin-left: 6px;
  border-radius: 999px;
  font-size: 11px;
  line-height: 16px;
  cursor: help;
  user-select: none;
  opacity: .75;
}
.sh-help:hover { opacity: 1; }
.sh-help[data-tooltip] { position: relative; }
.sh-help[data-tooltip]:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  bottom: 125%;
  transform: translateX(-50%);
  min-width: 220px;
  max-width: 360px;
  padding: 10px 12px;
  border-radius: 10px;
  font-size: 12px;
  line-height: 1.35;
  white-space: normal;
  z-index: 9999;
  box-shadow: 0 10px 25px rgba(0,0,0,.18);
  background: rgba(20,20,24,.96);
  color: #fff;
}
.sh-help[data-tooltip]:hover::before {
  content: "";
  position: absolute;
  left: 50%;
  bottom: 114%;
  transform: translateX(-50%);
  border: 7px solid transparent;
  border-top-color: rgba(20,20,24,.96);
}
</style>
<!-- STREAMER_HUB_HELP_STYLE_END -->
""".strip()

enhancer_script = r"""
<!-- STREAMER_HUB_ENHANCER_START -->
<script>
(() => {
  // -----------------------------
  // Param√®tres
  // -----------------------------
  const MAX_VIEWERS = 100;          // anti-mastodontes
  const MIN_VIEWERS = 0;
  const LANG = 'fr';

  const HELP = {
    "moyenne": "Moyenne de viewers sur la p√©riode. Utile pour mesurer ta base r√©elle (pas juste un pic).",
    "pic": "Le maximum de viewers atteint sur la p√©riode. Utile pour identifier un moment fort √† reproduire.",
    "croissance": "√âvolution entre le d√©but et la fin de la p√©riode. Utile pour voir si ton live 'monte' ou 's'essouffle'.",
    "volatilite": "Variations autour de la moyenne. Plus c'est haut, plus c'est instable (attention aux formats qui font fuir).",
    "heures": "Estimation de ton volume de live. Utile pour comparer effort vs r√©sultat.",
    "score": "Score (0-100) qui r√©sume potentiel + r√©gularit√©. Utile pour prioriser ce qui marche.",
    "saturation": "Plus c'est haut, plus il y a de concurrence pour une audience similaire. Cherche les cr√©neaux moins satur√©s.",
    "decouvrabilite": "Plus c'est haut, plus tu as de chances d'√™tre trouv√© (ratio audience / concurrence)."
  };

  // -----------------------------
  // Utilitaires
  // -----------------------------
  async function fetchJSON(url, opts) {
    const res = await fetch(url, opts);
    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data?.error || data?.message || 'Erreur API');
    return data;
  }

  function removeLuckButtonIfAny() {
    const buttons = Array.from(document.querySelectorAll('button'));
    buttons.forEach(b => {
      const txt = (b.textContent || '').toLowerCase();
      const id = (b.id || '').toLowerCase();
      if (txt.includes("j'ai de la chance") || txt.includes("chance") || id.includes("lucky") || id.includes("chance")) {
        b.remove();
      }
    });
  }

  function getParentParam() {
    // Twitch embed exige le param parent = domaine
    return window.location.hostname || 'localhost';
  }

  function findTwitchIframe() {
    return document.querySelector('iframe[src*="player.twitch.tv"]') || document.getElementById('twitchPlayer') || null;
  }

  function updateIframeChannel(channel) {
    const iframe = findTwitchIframe();
    if (!iframe) return false;
    const parent = getParentParam();
    const muted = "false";
    iframe.src = `https://player.twitch.tv/?channel=${encodeURIComponent(channel)}&parent=${encodeURIComponent(parent)}&muted=${muted}`;
    return true;
  }

  // Si ton HTML utilise le Twitch Embed officiel dans un <div id="twitch-embed">,
  // on essaie de le piloter (sans casser le visuel).
  function updateTwitchEmbedChannel(channel) {
    const embedDiv = document.getElementById('twitch-embed') || document.getElementById('twitchEmbed') || null;
    if (!embedDiv) return false;

    // r√©utilise un embed si existant
    if (window.__SH_EMBED && window.__SH_EMBED.getPlayer) {
      try {
        const p = window.__SH_EMBED.getPlayer();
        if (p && p.setChannel) { p.setChannel(channel); return true; }
      } catch (_) {}
    }

    // cr√©e un embed si possible (script twitch d√©j√† charg√© dans ton HTML)
    if (window.Twitch && window.Twitch.Embed) {
      try {
        window.__SH_EMBED = new window.Twitch.Embed(embedDiv.id, {
          width: "100%",
          height: "100%",
          channel,
          parent: [getParentParam()],
          layout: "video"
        });
        return true;
      } catch (_) {}
    }
    return false;
  }

  function setCurrentChannelLabel(channel, meta) {
    // optionnel: si tu as un endroit qui affiche la chaine
    const el =
      document.querySelector('[data-current-channel]') ||
      document.getElementById('currentChannel') ||
      document.getElementById('current_channel') ||
      null;
    if (el) {
      const game = meta?.game_name ? ` ¬∑ ${meta.game_name}` : '';
      const viewers = (meta?.viewers != null) ? ` ¬∑ ${meta.viewers} viewers` : '';
      el.textContent = `${channel}${game}${viewers}`;
    }
  }

  async function loadRandomGlobal() {
    const data = await fetchJSON(`/api/streams/random_global?language=${encodeURIComponent(LANG)}&min_viewers=${MIN_VIEWERS}&max_viewers=${MAX_VIEWERS}`);
    if (!data.success || !data.stream?.login) throw new Error('Aucun streamer trouv√© (0..100 viewers).');
    const login = data.stream.login;
    // essaie embed, sinon iframe
    const ok = updateTwitchEmbedChannel(login) || updateIframeChannel(login);
    setCurrentChannelLabel(login, data.stream);
    return ok;
  }

  async function loadRandomForGame(gameNameOrId) {
    const data = await fetchJSON(`/api/streams/random_for_game?game=${encodeURIComponent(gameNameOrId)}&language=${encodeURIComponent(LANG)}&min_viewers=${MIN_VIEWERS}&max_viewers=${MAX_VIEWERS}`);
    if (!data.success || !data.stream?.login) throw new Error('Aucun streamer trouv√© sur ce jeu (0..100 viewers).');
    const login = data.stream.login;
    const ok = updateTwitchEmbedChannel(login) || updateIframeChannel(login);
    setCurrentChannelLabel(login, data.stream);
    return ok;
  }

  function enhanceTopGamesClick() {
    // On √©coute globalement les clics sur des cards de jeux, sans pr√©sumer ton HTML.
    // R√®gles: si on clique sur un √©l√©ment qui a data-game / data-game-name / alt d'image => on charge un streamer.
    document.addEventListener('click', async (e) => {
      const t = e.target;
      if (!t) return;

      // Cherche game name dans data attributes
      const node = t.closest ? (t.closest('[data-game],[data-game-name],[data-gamename]') || t) : t;
      const dn =
        (node && node.dataset && (node.dataset.game || node.dataset.gameName || node.dataset.gamename)) ||
        (t && t.dataset && (t.dataset.game || t.dataset.gameName || t.dataset.gamename)) ||
        null;

      // alt d'image (souvent le nom du jeu)
      const alt = (t.tagName === 'IMG' && t.alt) ? t.alt.trim() : null;

      // Texte proche (si la card contient un <span> avec le nom)
      let nearbyText = null;
      try {
        const card = t.closest && t.closest('.game, .game-card, .gameCard, .top-game, .topGame, [data-game-card]') ? t.closest('.game, .game-card, .gameCard, .top-game, .topGame, [data-game-card]') : null;
        if (card) {
          const txt = (card.textContent || '').trim();
          if (txt && txt.length < 80) nearbyText = txt;
        }
      } catch(_) {}

      const gameName = dn || alt || nearbyText;
      if (!gameName) return;

      // √©viter de trigger sur des clicks partout: on n'active que si √ßa ressemble √† un jeu (et pas un gros bloc)
      if (gameName.length < 2 || gameName.length > 80) return;

      // Ici: clic sur un jeu => charger direct un streamer du jeu
      try {
        // (optionnel) feedback: tu peux afficher un loader si ton UI en a un.
        await loadRandomForGame(gameName);
      } catch(err) {
        // fallback: random global
        try { await loadRandomGlobal(); } catch(_) {}
        console.warn('[Game->Stream]', err?.message || err);
      }
    }, true);
  }

  function addHelpBubbles() {
    // Ajoute des petits (i) pr√®s des labels si on reconna√Æt des mots cl√©s.
    // Z√©ro impact si tes √©l√©ments n'existent pas.
    const patterns = [
      { re: /moyenne/i, key: "moyenne" },
      { re: /\bpic\b|peak|max/i, key: "pic" },
      { re: /croissance|growth/i, key: "croissance" },
      { re: /volatil/i, key: "volatilite" },
      { re: /heures|hours/i, key: "heures" },
      { re: /score/i, key: "score" },
      { re: /saturation/i, key: "saturation" },
      { re: /d√©couvr|discover/i, key: "decouvrabilite" }
    ];

    const candidates = Array.from(document.querySelectorAll('h1,h2,h3,h4,h5,label,span,div,p,strong'))
      .filter(el => el && el.childElementCount === 0)
      .slice(0, 2500); // garde perf

    candidates.forEach(el => {
      const txt = (el.textContent || '').trim();
      if (!txt || txt.length > 60) return;
      if (el.querySelector && el.querySelector('.sh-help')) return;

      const found = patterns.find(p => p.re.test(txt));
      if (!found) return;

      // si title d√©j√† pr√©sent, ne pas ajouter
      if (el.getAttribute('title')) return;

      // Ajoute un "i" discret
      const info = document.createElement('span');
      info.className = 'sh-help';
      info.textContent = 'i';
      info.setAttribute('aria-label', 'Info');
      info.setAttribute('data-tooltip', HELP[found.key] || '');
      el.appendChild(info);
    });
  }

  function translateSomeLabelsToFrench() {
    // Si certaines labels sont en anglais, on les remplace (sans changer le style)
    const map = [
      [/Average Viewers/i, 'Moyenne viewers'],
      [/Peak Viewers/i, 'Pic viewers'],
      [/Growth/i, 'Croissance'],
      [/Volatility/i, 'Volatilit√©'],
      [/Hours per week/i, 'Heures / semaine'],
      [/Growth score/i, 'Score de croissance'],
      [/Discoverability/i, 'D√©couvrabilit√©'],
      [/Saturation/i, 'Saturation']
    ];

    const nodes = Array.from(document.querySelectorAll('body *'))
      .filter(el => el.childElementCount === 0)
      .slice(0, 5000);

    nodes.forEach(el => {
      const t = el.textContent;
      if (!t || t.length > 40) return;
      for (const [re, fr] of map) {
        if (re.test(t)) { el.textContent = fr; break; }
      }
    });
  }

  function lockSocketToWebsocketIfAny() {
    // Si ton HTML cr√©e un socket.io client, on ne peut pas forc√©ment l'emp√™cher ici.
    // MAIS on peut te proposer un patch "client" plus tard si tu veux.
  }

  async function ensureInitialStream() {
    // Si le lecteur d√©marre sur "twitch" ou vide, on propose direct un petit streamer (0..100).
    // On ne force pas si tu as d√©j√† un channel charg√©.
    const iframe = findTwitchIframe();
    if (iframe && iframe.src && iframe.src.includes('channel=')) return;

    try {
      await loadRandomGlobal();
    } catch (e) {
      console.warn('No initial stream:', e?.message || e);
    }
  }

  // -----------------------------
  // BOOT
  // -----------------------------
  window.addEventListener('DOMContentLoaded', () => {
    removeLuckButtonIfAny();
    translateSomeLabelsToFrench();
    addHelpBubbles();
    enhanceTopGamesClick();
    ensureInitialStream();
    lockSocketToWebsocketIfAny();
  });
})();
</script>
<!-- STREAMER_HUB_ENHANCER_END -->
""".strip()

def upsert_block(html_text, start_marker, end_marker, new_block, insert_before_pattern):
    # Remove existing block if present
    pattern = re.compile(re.escape(start_marker) + r".*?" + re.escape(end_marker), re.DOTALL)
    html_text = re.sub(pattern, new_block, html_text)
    if start_marker in html_text and end_marker in html_text:
        return html_text
    # else insert
    m = re.search(insert_before_pattern, html_text, flags=re.IGNORECASE)
    if not m:
        return html_text + "\n" + new_block + "\n"
    idx = m.start()
    return html_text[:idx] + new_block + "\n" + html_text[idx:]

# Insert style in head (before </head>)
patched = orig_html
if "STREAMER_HUB_HELP_STYLE_START" not in patched:
    patched = upsert_block(
        patched,
        "<!-- STREAMER_HUB_HELP_STYLE_START -->",
       
